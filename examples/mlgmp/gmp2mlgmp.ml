module Gmp = struct
	type rounding_mode = GMP_RNDN | GMP_RNDZ | GMP_RNDU | GMP_RNDD;;
	module RNG = struct
		type randalg_t = GMP_RAND_ALG_LC of int;;
		let randinit a =
			match a with
			| GMP_RAND_ALG_LC size -> Gmp.Random.create_lc_2exp_size size
	end;;
	module Z = struct
		type t = Gmp.Z.t;;
		let zero = Gmp.Z.zero;;
		let one = Gmp.Z.one;;
		let compare = Gmp.Z.compare;;
		let cmp = Gmp.Z.compare;;
		let cmp_si = Gmp.Z.compare_int;;
		let equal x y = Gmp.Z.compare x y = 0;;
		let equal_int x y = Gmp.Z.compare_int x y = 0;;
		let sgn x = Gmp.Z.compare x Gmp.Z.zero;;
		let neg = Gmp.Z.neg;;
		let abs = Gmp.Z.abs;;
		let add = Gmp.Z.add;;
		let add_ui = Gmp.Z.add_int;;
		let sub = Gmp.Z.sub;;
		let sub_ui x y = Gmp.Z.add_int x (-y);;
		let mul = Gmp.Z.mul;;
		let mul_ui x y = Gmp.Z.mul x (Gmp.Z.of_int y);;
		let mul2exp x y = Gmp.Z.scale x ~base:2 ~exponent:y;;
		let mul_2exp x y = Gmp.Z.scale x ~base:2 ~exponent:y;;
		let cdiv_qr = Gmp.Z.cdiv;;
		let cdiv_q x y = fst (Gmp.Z.cdiv x y);;
		let cdiv_q_2exp x y = fst (Gmp.Z.cdiv x (Gmp.Z.int_pow_int 2 y));;
		let cdiv_r x y = snd (Gmp.Z.cdiv x y);;
		let cdiv_r_ui x y = snd (Gmp.Z.cdiv x (Gmp.Z.of_int y));;
		let fdiv_q x y = fst (Gmp.Z.fdiv x y);;
		let fdiv_q_ui x y = fst (Gmp.Z.fdiv x (Gmp.Z.of_int y));;
		let fdiv_q_2exp x y = Gmp.Z.scale x ~base:2 ~exponent:(-y);;
		let modulo = Gmp.Z.modulo;;
		let dmod_ui x y = Gmp.Z.modulo x (Gmp.Z.of_int y);;
		let pow_ui = Gmp.Z.pow_int;;
		let pow_ui_ui = Gmp.Z.int_pow_int;;
		let powm _ _ _ = assert false;;
		let powm_ui _ _ _ = assert false;;
		let sqrt = Gmp.Z.sqrt;;
		let sqrtrem = Gmp.Z.tsqrt;;
		let root x y = Gmp.Z.pow_q x (Gmp.Q.make_int 1 y);;
		let nextprime _ = assert false;;
		let gcdext = Gmp.Z.gcdext;;
		let inverse = Gmp.Z.invert;;
		let legendre _ _ = assert false;;
		let remove _ _ = assert false;;
		let fac_ui _ = assert false;;
		let bin_ui ~n ~k = assert false;;
		let fib_ui _ = assert false;;
		let perfect_power_p = Gmp.Z.is_perfect_power;;
		let perfect_square_p = Gmp.Z.is_perfect_square;;
		let is_prime _ = assert false;;
		let is_probab_prime _ = assert false;;
		let bior = Gmp.Z.logor;;
		let scan0 _ _ = assert false;;
		let scan1 _ _ = assert false;;
		let from_int = Gmp.Z.of_int;;
		let from_float = Gmp.z_of_truncated_float;;
		let from_string_base = Gmp.Z.of_based_string;;
		let from_string x = Gmp.Z.of_string x;;
		let to_int = Gmp.Z.to_int;;
		let int_from = Gmp.Z.to_int;;
		let to_float = Gmp.Z.to_float;;
		let to_string_base = Gmp.Z.to_based_string;;
		let to_string = Gmp.Z.to_string;;
		let urandomm = Gmp.Random.z;;
		let output oc n = output_string oc (Gmp.Z.to_string n);;
	end;;
	module Q = struct
		type t = Gmp.Q.t;;
		let compare = Gmp.Q.compare;;
		let cmp = Gmp.Q.compare;;
		let cmp_ui x n d = Gmp.Q.compare x (Gmp.Q.make_int n d);;
		let equal x y = Gmp.Q.compare x y = 0;;
		let is_zero x = Gmp.Q.compare x Gmp.Q.zero = 0;;
		let sgn x = Gmp.Q.compare x Gmp.Q.zero;;
		let neg = Gmp.Q.neg;;
		let add = Gmp.Q.add;;
		let sub = Gmp.Q.sub;;
		let mul = Gmp.Q.mul;;
		let div = Gmp.Q.div;;
		let inv x = Gmp.Q.make_z (Gmp.Q.den x) (Gmp.Q.num x);;
		let get_num = Gmp.Q.num;;
		let get_den = Gmp.Q.den;;
		let from_int = Gmp.Q.of_int;;
		let from_si = Gmp.Q.make_int;;
		let from_ints = Gmp.Q.make_int;;
		let from_z = Gmp.Q.of_z;;
		let from_zs = Gmp.Q.make_z;;
		let from_float = Gmp.Q.of_float;;
		let to_float = Gmp.Q.to_float;;
		let float_from = Gmp.Q.to_float;;
		let to_string = Gmp.Q.to_string;;
		let sprintf () = to_string;;
	end;;
	module F = struct
		let default_prec = 120;;
		module Default_F = Gmp.F (struct let prec = default_prec end);;
		let zero = Default_F.zero;;
		let compare = Default_F.compare;;
		let equal x y = Default_F.compare x y = 0;;
		let eq ~prec x y = assert false;;
		let sgn x = Default_F.compare x Default_F.zero;;
		let neg = Default_F.neg;;
		let abs = Default_F.abs;;
		let add = Default_F.add;;
		let add_ui = Default_F.add_int;;
		let sub = Default_F.sub;;
		let sub_ui x y = Default_F.add_int x (-y);;
		let mul = Default_F.mul;;
		let mul_ui x y = Default_F.mul x (Default_F.of_int y);;
		let floor _ = assert false;;
		let from_int = Default_F.of_int;;
		let from_float = Default_F.of_float;;
		let from_string_base = Default_F.of_based_string;;
		let from_string = Default_F.of_string;;
		let to_float = Default_F.to_float;;
		let to_string = Default_F.to_string;;
		let urandomb ~state ~nbits = Gmp.Random.f_bits state nbits;;
	end;;
	module FR = struct
		let default_prec = 120;;
		module Default_FR = Mpfr.FR (struct let prec = default_prec end);;
		let compare = Default_FR.compare;;
		let eq ~prec x y = assert false;;
		let sgn = Default_FR.compare Default_FR.zero;;
		let neg = Default_FR.neg ~mode:`N;;
		let abs = Default_FR.abs ~mode:`N;;
		let add = Default_FR.add ~mode:`N;;
		let add_ui = Default_FR.add_int ~mode:`N;;
		let sub = Default_FR.add ~mode:`N;;
		let sub_ui x y = Default_FR.add_int ~mode:`N x (-y);;
		let mul = Default_FR.add ~mode:`N;;
		let mul_ui x y = Default_FR.add ~mode:`N x (Default_FR.of_int ~mode:`N y);;
		let pow_ui = Default_FR.pow_int ~mode:`N;;
		let sqrt = Default_FR.sqrt;;
		let exp _ = assert false;;
		let exp2 _ = assert false;;
		let floor _ = assert false;;
		let sin _ = assert false;;
		let acosh _ = assert false;;
		let from_int = Default_FR.of_int ~mode:`N;;
		let from_float = Default_FR.of_float ~mode:`N;;
		let from_string_base = Default_FR.of_based_string ~mode:`N;;
		let from_string = Default_FR.of_string ~mode:`N;;
		let to_float = Default_FR.to_float ~mode:`N;;
		let to_string = Default_FR.to_string ~mode:`N;;
		let to_string_base_digits _ = assert false;;
	end;;
	exception Unimplemented of string;;
end;;
